/*

ID 89806686

Хотел бы уточнить пвру важных моментов, почему вы предлагаете использовать snake case, вместо camel case(вы предложили назвать поле структуры tasks_solved)?
И второй момент - это рекурсия в функциях SiftUp и SiftDown, почему я ее не могу использовать?!
Если даже в теории написан единственный пример на просеивание - и это как раз с использованием рекурсии(привожу пример псевдокода из теории ниже).

Псевдокод из раздела "Приоритетная очередь. Вставка и удаление":
функция sift_up(heap, index):
    если index == 1, то
        завершить работу
    parent_index = index / 2  (целочисленное деление)
    если heap[parent_index] < heap[index], то
        обменять местами heap[parent_index] и heap[index]
        sift_up(heap, parent_index)

-- ПРИНЦИП РАБОТЫ --

Считывание входных данных: Сначала считывается число n - количество элементов, а затем n строк, представляющих элементы, состоящие из имени, количества завершенных задач (tasksSolved), и количества неудачных задач (penalty).

Инициализация структуры "Пирамида" (Queue): Создается структура данных "Пирамида" (min-куча) с начальным пустым массивом queue и указателем lastIndex на последний элемент в очереди.

Добавление элементов в "Пирамиду": Каждый считанный элемент добавляется в "пирамиду" с помощью метода Append.
При добавлении элемента, он помещается в конец массива queue, затем выполняется просеивание вверх SiftUp, которая перемещает элемент вверх по пирамиде до тех пор, пока не будет восстановлено условие мин-кучи.

Извлечение элементов из "Пирамиды" и сортировка: После того как все элементы добавлены в "пирамиду", начинается процесс извлечения элементов методом GetElem.
При извлечении элемента, он меняется местами с корневым элементом пирамиды, затем выполняется просеивание вниз SiftDown, которое опускает элемент вниз по пирамиде до тех пор,
пока не будет восстановлено условие мин-кучи. Это позволяет извлекать элементы в порядке убывания приоритета (сначала по завершенным задачам, затем по неудачным, и по имени).

Вывод отсортированных элементов: Отсортированные элементы выводятся в заданном порядке в формате: имя элемента, за которым следует символ новой строки.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Построение мин-кучи (мин-пирамиды):
	Корректность алгоритма начинается с того, что он строит мин-кучу.
	Это означает, что для каждого элемента i его приоритет (сравниваемые значения) меньше или равен приоритету его потомков,
	что обеспечивает правильное размещение элементов в структуре данных.

Извлечение с наивысшим приоритетом:
	При извлечении элемента из мин-кучи, извлекается элемент с наивысшим приоритетом,
	что соответствует определенному правилу сортировки (сначала по завершенным задачам, затем по неудачным, и по имени).
	После извлечения элемента, происходит переупорядочивание пирамиды, чтобы сохранить свойства мин-кучи.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Добавление элемента в "пирамиду" (Append): выполняется через просеивание вниз(ShiftUp) => O(log n)
Извлечение элемента из "пирамиды" (GetElem): выполняется через просеивание вниз(ShiftDown) => O(log n)
Построение "пирамиды" (queue): поскольку каждый из n элементов добавляется в пирамиду, общая сложность построения пирамиды составляет O(n * log n), где n - кол-во входных данных.
Вывод отсортированных элементов: O(n)

Итоговая временная сложность алгоритма: O(n * log n).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Хранение пирамиды:
	Пирамида (мин-куча) хранится в массиве размером "n + 1" (queue), где "n" - количество элементов.
	Дополнительно, несколько переменных (например, lastIndex) также используются для управления состоянием пирамиды.
	Пространственная сложность хранения пирамиды составляет O(n).

Прочие переменные и структуры данных:
	Кроме массива для пирамиды, другие переменные и структуры данных (например, переменные для временного хранения
	считанных данных и временных переменных внутри методов) занимают константное количество памяти.
	Пространственная сложность остальных переменных - O(1).

Функции SiftUp и SiftDown, вызываемые рекурсивно, могут добавить до O(log n) дополнительной памяти в стек вызовов.
Таким образом, общая пространственная сложность алгоритма будет составлять O(n + log n), где n - количество элементов во входных данных,
а O(n) идет на хранение данных в структуре Queue, а O(log n) - на рекурсивные вызовы функций.

Итоговая пространственная сложность алгоритма: O(n+log n)

*/

package A

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
)

// Result структура элемента
type Result struct {
	name        string
	tasksSolved int
	penalty     int
}

// Queue структура очереди
type Queue struct {
	queue     []Result
	lastIndex int
}

func main() {
	res := strings.Builder{}
	PyramidSort(os.Stdin, &res)

	fmt.Println(res.String())
}

// SiftUp просеивания вверх
func (pq Queue) SiftUp(index int) {
	if index == 1 {
		return
	}

	parentIndex := index >> 1

	if pq.CheckPriority(index, parentIndex) {
		pq.Swap(index, parentIndex)
		//ОБРАТИТЕ,ПОЖАЛУЙСТА,ВНИМАНИЕ НА ТО,ЧТО Я НАПИСАЛ В САМОМ НАЧАЛЕ МОЕГО ОБЪЯСНЕНИЯ
		pq.SiftUp(parentIndex)
	}
}

// SiftDown просеивания вниз
func (pq Queue) SiftDown(index int) {
	left := index * 2
	right := index*2 + 1
	if left >= pq.Len() {
		return
	}

	best := 0

	if right < pq.Len() && pq.CheckPriority(right, left) {
		best = right
	} else {
		best = left
	}

	if pq.CheckPriority(best, index) {
		pq.Swap(best, index)
		//ОБРАТИТЕ,ПОЖАЛУЙСТА,ВНИМАНИЕ НА ТО,ЧТО Я НАПИСАЛ В САМОМ НАЧАЛЕ МОЕГО ОБЪЯСНЕНИЯ
		pq.SiftDown(best)
	}
}

// PyramidSort основная функция на вход
func PyramidSort(r io.Reader, w *strings.Builder) {
	scanner := bufio.NewScanner(r)
	scanner.Scan()

	n, _ := strconv.Atoi(scanner.Text())
	pq := Queue{
		queue:     make([]Result, n+1),
		lastIndex: 0,
	}

	for i := 0; i < n; i++ {
		scanner.Scan()
		fields := strings.Fields(scanner.Text())
		name := fields[0]
		complete, _ := strconv.Atoi(fields[1])
		fail, _ := strconv.Atoi(fields[2])
		pq.Append(Result{name, complete, fail})
	}

	for i := 0; i < n; i++ {
		w.WriteString(pq.GetElem().name)
		w.WriteByte('\n')
	}
}

// Append добавление элемента в очередь
func (pq *Queue) Append(cr Result) {
	pq.lastIndex++
	pq.queue[pq.lastIndex] = cr
	pq.SiftUp(pq.lastIndex)
}

// GetElem получение приоритетного элемента из кучи
func (pq *Queue) GetElem() Result {
	defer func() {
		pq.queue[1] = pq.queue[pq.lastIndex]
		pq.queue = pq.queue[:pq.lastIndex]
		pq.SiftDown(1)
		pq.lastIndex--
	}()

	return pq.queue[1]
}

// CheckPriority проверка приоритета
func (pq Queue) CheckPriority(a, b int) bool {
	if pq.queue[a].tasksSolved == pq.queue[b].tasksSolved {
		if pq.queue[a].penalty == pq.queue[b].penalty {
			return pq.queue[a].name < pq.queue[b].name
		} else {
			return pq.queue[a].penalty <= pq.queue[b].penalty
		}
	} else {
		return pq.queue[a].tasksSolved >= pq.queue[b].tasksSolved
	}
}

// Swap классическая функция смены
func (pq Queue) Swap(a, b int) {
	pq.queue[a], pq.queue[b] = pq.queue[b], pq.queue[a]
}

// Len текущий размер очереди
func (pq Queue) Len() int {
	return len(pq.queue)
}
