/*
ID 90083776

-- ПРИНЦИП РАБОТЫ --

Сначала считывается количество городов n и создаются две структуры данных: matrix (матрица смежности) и visited (массив для отслеживания статуса вершин).

Затем происходит сбор матрицы смежности matrix. В матрице matrix[i] хранятся индексы городов, в которые можно доехать напрямую из города i.
Если дорога между городами существует, то в матрицу добавляется соответствующая связь.

Далее вызывается метод checkOptimal, который осуществляет поиск в глубину (DFS) в матрице matrix, чтобы проверить, можно ли построить оптимальное железнодорожное сообщение.

Внутри checkOptimal каждая вершина помечается одним из трех статусов: WHITE (не обработанная вершина), GRAY (обнаруженная вершина) или BLACK (обработанная вершина).
Затем алгоритм выполняет DFS, проверяя цвета вершин и возвращая false, если обнаруживается цикл (GRAY вершина соединяется с GRAY вершиной).

Если после обхода всей матрицы нет циклов, алгоритм возвращает true, что означает, что можно построить оптимальное железнодорожное сообщение.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

Алгоритм проверяет наличие циклов в графе.
Если цикл существует, то невозможно построить оптимальное железнодорожное сообщение, так как это приведет к бесконечному циклу.
Если же циклов нет, то оптимальное сообщение может быть построено, так как граф будет ациклическим.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Вершины (V): Алгоритм посещает каждую вершину ровно один раз во время поиска в глубину. Это займет O(V) времени.

Рёбра (E): Алгоритм также идет по каждому ребру ровно один раз. В наихудшем случае, когда каждая вершина соединена со всеми другими вершинами (полный граф),
число рёбер будет максимальным, и мы можем считать m пропорциональным к V^2. Таким образом, максимальное число рёбер m будет O(V^2).

Время выполнения для DFS: Время выполнения поиска в глубину (DFS) в худшем случае равно O(V + E).
В данном случае, учитывая, что E не больше, чем V^2, временная сложность DFS будет O(V + V^2) = O(V^2).

Итак, общая временная сложность алгоритма будет O(V^2).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Вершины (V): Для каждой вершины необходимо хранить информацию о её статусе (WHITE, GRAY, BLACK) в массиве visited. Это потребует O(V) дополнительной памяти.

Рёбра (E): Для представления графа в виде матрицы смежности matrix, потребуется O(V^2) дополнительной памяти,
так как в худшем случае каждая вершина будет соединена со всеми другими вершинами.

Пространство для стека DFS: В худшем случае, стек DFS может содержать все вершины графа (в случае отсутствия циклов).
Это потребует дополнительную память O(V).

Итак, общая пространственная сложность алгоритма будет O(V^2 + V) = O(V^2).

*/

package B

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
)

// Matrix основная матрица
type Matrix [][]int

// VertexStat статус вершины
type VertexStat uint8

const (
	_ VertexStat = iota
	// WHITE не обработанная вершина
	WHITE
	// GRAY обнаруженная вершина
	GRAY
	// BLACK обработанная вершина
	BLACK
)

const (
	RType = 'R'
	YES   = "YES"
	NO    = "NO"
)

func main() {
	res := strings.Builder{}
	Solution(os.Stdin, &res)

	fmt.Println(res.String())
}

// Solution решение задачи
func Solution(r io.Reader, w *strings.Builder) {
	scanner := bufio.NewScanner(r)
	scanner.Scan()

	// количество городов
	n, err := strconv.Atoi(strings.TrimSpace(scanner.Text()))
	if err != nil {
		log.Fatal(err)
	}

	matrix := make(Matrix, n+1)
	visited := make([]VertexStat, n+1)

	// соберем матрицу
	for i := 1; i <= n; i++ {
		scanner.Scan()
		railData := scanner.Text()

		// по умолчанию вершина не посещена
		visited[i] = WHITE

		for j := 0; j < len(railData); j++ {
			target := i + j + 1
			// тип дороги R
			if railData[j] == RType {
				matrix[i] = append(matrix[i], target)
			} else {
				matrix[target] = append(matrix[target], i)
			}
		}
	}

	if matrix.checkOptimal(visited, n) {
		w.WriteString(YES)
		return
	}
	w.WriteString(NO)
}

// checkOptimal обход матрицы в поисках путей
func (m Matrix) checkOptimal(visited []VertexStat, n int) bool {
	for i := 1; i <= n; i++ {
		if visited[i] != WHITE {
			continue
		}

		stack := []int{i}
		for len(stack) > 0 {
			current := stack[len(stack)-1]

			if visited[current] == WHITE {
				visited[current] = GRAY

				for _, target := range m[current] {
					if visited[target] == WHITE {
						stack = append(stack, target)
					} else if visited[target] == GRAY {
						return false
					}
				}

			} else {
				visited[current] = BLACK
				stack = stack[:len(stack)-1]
			}
		}
	}

	return true
}
